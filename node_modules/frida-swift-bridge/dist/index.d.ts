/**
 * TODO:
 *  - Use proper platform checks (CPU and OS)
 *  - Use strict null checks?
 *  - Use platform-agnostic data structure sizes (size_t et al.)
 *  - Register for notification when a new module is added
 *  - Add demangled symbol look-up
 *  - Add parsing of function names
 *  - inout params
 */
import { Api } from "./lib/api.js";
import { Class, Struct, Enum, Protocol, ProtocolComposition, EnumValue, ObjectInstance, StructValue, Type } from "./lib/types.js";
import { SwiftModule } from "./lib/registry.js";
import { SwiftInterceptor } from "./lib/interceptor.js";
type ConvenientSwiftType = Type | Protocol | ProtocolComposition | NativeFunctionReturnType | NativeFunctionArgumentType;
declare class Runtime {
    #private;
    constructor();
    get available(): boolean;
    get api(): Api;
    get modules(): Record<string, SwiftModule>;
    get classes(): Record<string, Class>;
    get structs(): Record<string, Struct>;
    get enums(): Record<string, Enum>;
    get protocols(): Record<string, Protocol>;
    readonly Object: typeof ObjectInstance;
    readonly Struct: typeof StructValue;
    readonly Enum: typeof EnumValue;
    readonly ProtocolComposition: typeof ProtocolComposition;
    readonly Interceptor: typeof SwiftInterceptor;
    NativeFunction(address: NativePointer, retType: ConvenientSwiftType, argTypes: ConvenientSwiftType[], context?: NativePointer, throws?: boolean): import("./lib/callingconvention.js").SwiftNativeFunction;
    private tryInitialize;
}
declare const _default: Runtime;
export default _default;
