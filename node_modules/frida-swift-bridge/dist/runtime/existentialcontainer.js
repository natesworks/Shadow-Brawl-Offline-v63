import { TargetClassMetadata, TargetValueBuffer, TargetValueMetadata, } from "../abi/metadata.js";
import { HeapObject } from "./heapobject.js";
export class TargetOpaqueExistentialContainer {
    handle;
    numWitnessTables;
    static INITIAL_SIZE = 4 * Process.pointerSize;
    static OFFSETOF = {
        buffer: 0,
        type: Process.pointerSize * 3,
        wintessTable: Process.pointerSize * 4,
    };
    #buffer;
    #type;
    constructor(handle, numWitnessTables) {
        this.handle = handle;
        this.numWitnessTables = numWitnessTables;
    }
    static alloc(numWitnessTables) {
        const size = TargetOpaqueExistentialContainer.INITIAL_SIZE +
            numWitnessTables * Process.pointerSize;
        const buf = Memory.alloc(size);
        return new TargetOpaqueExistentialContainer(buf, numWitnessTables);
    }
    static makeFromRaw(handle, numWitnessTables) {
        const container = new TargetOpaqueExistentialContainer(handle, numWitnessTables);
        const metadataPtr = handle
            .add(TargetOpaqueExistentialContainer.OFFSETOF.type)
            .readPointer();
        const tmpMetadata = new TargetValueMetadata(metadataPtr);
        container.#type = tmpMetadata.isClassObject()
            ? new TargetClassMetadata(metadataPtr)
            : tmpMetadata;
        return container;
    }
    set type(metadata) {
        this.handle
            .add(TargetOpaqueExistentialContainer.OFFSETOF.type)
            .writePointer(metadata.handle);
        this.#type = metadata;
    }
    get buffer() {
        if (this.#buffer === undefined) {
            this.#buffer = new TargetValueBuffer(this.handle);
        }
        return this.#buffer;
    }
    // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures
    get type() {
        return this.#type;
    }
    getWitnessTables() {
        return this.handle.add(TargetOpaqueExistentialContainer.OFFSETOF.wintessTable);
    }
    isValueInline() {
        return this.type.getValueWitnesses().isValueInline();
    }
    projectValue() {
        const vwt = this.type.getValueWitnesses();
        if (vwt.isValueInline()) {
            return this.buffer.privateData;
        }
        const heapObject = this.buffer.privateData.readPointer();
        const alignMask = vwt.getAlignmentMask();
        const byteOffset = (HeapObject.SIZEOF + alignMask) & ~alignMask;
        return heapObject.add(byteOffset);
    }
    get sizeof() {
        return (TargetOpaqueExistentialContainer.INITIAL_SIZE +
            this.numWitnessTables * Process.pointerSize);
    }
}
/* FIXME: prefix name with 'Target' */
export class ClassExistentialContainer {
    handle;
    numWitnessTables;
    static INITIAL_SIZE = Process.pointerSize;
    static OFFSETOF = {
        value: 0,
        witnessTables: Process.pointerSize,
    };
    #value;
    constructor(handle, numWitnessTables) {
        this.handle = handle;
        this.numWitnessTables = numWitnessTables;
    }
    static alloc(numWitnessTables) {
        const size = ClassExistentialContainer.INITIAL_SIZE +
            numWitnessTables * Process.pointerSize;
        const buf = Memory.alloc(size);
        return new ClassExistentialContainer(buf, numWitnessTables);
    }
    static makeFromRaw(handle, numWitnessTables) {
        const container = new ClassExistentialContainer(handle, numWitnessTables);
        container.#value = handle
            .add(ClassExistentialContainer.OFFSETOF.value)
            .readPointer();
        return container;
    }
    get value() {
        return this.#value;
    }
    set value(newValue) {
        this.handle
            .add(ClassExistentialContainer.OFFSETOF.value)
            .writePointer(newValue);
        this.#value = newValue;
    }
    getWitnessTables() {
        return this.handle.add(ClassExistentialContainer.OFFSETOF.witnessTables);
    }
    get sizeof() {
        return (ClassExistentialContainer.INITIAL_SIZE +
            this.numWitnessTables * Process.pointerSize);
    }
}
