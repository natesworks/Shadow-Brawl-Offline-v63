import { MetadataKind } from "../abi/metadatavalues.js";
import { makeBufferFromValue, sizeInQWordsRounded } from "./buffer.js";
import { INDRIECT_RETURN_REGISTER, MAX_LOADABLE_SIZE, shouldPassIndirectly, } from "./callingconvention.js";
import { findProtocolDescriptor, getDemangledSymbol, untypedMetadataFor, } from "./macho.js";
import { parseSwiftMethodSignature } from "./symbols.js";
import { EnumValue, ObjectInstance, ProtocolComposition, StructValue, ValueInstance, } from "./types.js";
export var SwiftInterceptor;
(function (SwiftInterceptor) {
    function attach(target, callbacks) {
        const symbol = getDemangledSymbol(target);
        const parsed = parseSwiftMethodSignature(symbol);
        let indirectRetAddr;
        const onEnter = function (args) {
            indirectRetAddr = this.context[INDRIECT_RETURN_REGISTER];
            if (callbacks.onEnter !== undefined) {
                const swiftyArgs = [];
                let argsIndex = 0;
                let currentArg;
                for (const argTypeName of parsed.argTypeNames) {
                    if (isProtocolTypeName(argTypeName)) {
                        const composition = ProtocolComposition.fromSignature(argTypeName);
                        const size = composition.sizeofExistentialContainer;
                        let buf;
                        if (size <= MAX_LOADABLE_SIZE) {
                            const sizeQWords = sizeInQWordsRounded(size);
                            const end = argsIndex + sizeQWords;
                            const raw = sliceArgs(args, argsIndex, end);
                            buf = makeBufferFromValue(raw);
                            argsIndex += sizeQWords;
                        }
                        else {
                            buf = args[argsIndex++];
                        }
                        currentArg = ValueInstance.fromExistentialContainer(buf, composition);
                        swiftyArgs.push(currentArg);
                        continue;
                    }
                    const argType = untypedMetadataFor(argTypeName);
                    if (argType.isClassObject()) {
                        currentArg = new ObjectInstance(args[argsIndex++]);
                    }
                    else {
                        const sizeQWords = sizeInQWordsRounded(argType.getTypeLayout().stride);
                        const kind = argType.getKind();
                        const end = argsIndex + sizeQWords;
                        const raw = sliceArgs(args, argsIndex, end);
                        if (kind === MetadataKind.Struct) {
                            const metadata = argType;
                            currentArg = new StructValue(metadata, { raw });
                        }
                        else if (kind === MetadataKind.Enum) {
                            const metadata = argType;
                            currentArg = new EnumValue(metadata, { raw });
                        }
                        else {
                            throw new Error("Unhandled metadata kind: " + kind);
                        }
                        argsIndex += sizeQWords;
                    }
                    swiftyArgs.push(currentArg);
                }
                const swiftyOnEnter = callbacks.onEnter.bind(this);
                swiftyOnEnter(swiftyArgs);
            }
        };
        let onLeave;
        if (callbacks.onLeave !== undefined) {
            onLeave = function (retval) {
                const retTypeName = parsed.retTypeName;
                let swiftyRetval;
                if (isProtocolTypeName(retTypeName)) {
                    const composition = ProtocolComposition.fromSignature(retTypeName);
                    const size = composition.sizeofExistentialContainer;
                    let buf;
                    if (size <= MAX_LOADABLE_SIZE) {
                        const sizeQWords = sizeInQWordsRounded(size);
                        const raw = [];
                        for (let i = 0; i != sizeQWords; i++) {
                            raw.push(this.context[`x${i}`]);
                        }
                        buf = makeBufferFromValue(raw);
                    }
                    else {
                        buf = indirectRetAddr;
                    }
                    swiftyRetval = ValueInstance.fromExistentialContainer(buf, composition);
                }
                else {
                    const retType = untypedMetadataFor(parsed.retTypeName);
                    if (retType.isClassObject()) {
                        swiftyRetval = new ObjectInstance(retval);
                    }
                    else {
                        const stride = retType.getTypeLayout().stride;
                        if (stride <= MAX_LOADABLE_SIZE &&
                            !shouldPassIndirectly(retType)) {
                            const sizeQWords = sizeInQWordsRounded(retType.getTypeLayout().stride);
                            const raw = [];
                            for (let i = 0; i < sizeQWords; i++) {
                                raw.push(this.context[`x${i}`]);
                            }
                            swiftyRetval = ValueInstance.fromRaw(raw, retType);
                        }
                        else {
                            swiftyRetval = ValueInstance.fromCopy(indirectRetAddr, retType);
                        }
                    }
                }
                const swiftyOnLeave = callbacks.onLeave.bind(this);
                swiftyOnLeave(swiftyRetval);
            };
        }
        return Interceptor.attach(target, {
            onEnter,
            onLeave,
        });
    }
    SwiftInterceptor.attach = attach;
})(SwiftInterceptor || (SwiftInterceptor = {}));
function isProtocolTypeName(name) {
    return name.indexOf("&") > -1 || findProtocolDescriptor(name);
}
function sliceArgs(args, start, end) {
    const result = [];
    for (let i = start; i != end; i++) {
        result.push(args[i]);
    }
    return result;
}
