import { TargetTypeContextDescriptor, TargetProtocolDescriptor, TargetClassDescriptor, TargetStructDescriptor, TargetEnumDescriptor, TargetMetadata, TargetProtocolConformanceDescriptor, } from "../abi/metadata.js";
import { ContextDescriptorKind } from "../abi/metadatavalues.js";
import { getPrivateAPI } from "./api.js";
import { RelativeDirectPointer } from "../basic/relativepointer.js";
import { demangledSymbolFromAddress, findProtocolNameInConformanceDescriptor } from "./symbols.js";
const allModules = new ModuleMap();
const protocolDescriptorMap = {};
const fullTypeDataMap = {};
const demangledSymbols = new Map();
/* XXX: Ugly hack(TM) until we lazily-parse MachOs */
if (Process.arch === "arm64" && Process.platform === "darwin") {
    for (const module of allModules.values()) {
        for (const descriptor of enumerateTypeDescriptors(module)) {
            /* TODO: figure out why multiple descriptors could have the same name */
            fullTypeDataMap[descriptor.getFullTypeName()] = {
                descriptor,
                conformances: {},
            };
        }
        for (const descriptor of enumerateProtocolDescriptors(module)) {
            protocolDescriptorMap[descriptor.getFullProtocolName()] = descriptor;
        }
    }
    for (const module of allModules.values()) {
        bindProtocolConformances(module);
    }
}
export function getAllFullTypeData() {
    return Object.values(fullTypeDataMap);
}
export function untypedMetadataFor(typeName) {
    const fullTypeData = fullTypeDataMap[typeName];
    if (fullTypeData === undefined) {
        throw new Error("Type not found: " + typeName);
    }
    if (fullTypeData.metadata !== undefined) {
        return fullTypeDataMap[typeName].metadata;
    }
    const metadataPtr = fullTypeData.descriptor
        .getAccessFunction()
        .call();
    const metadata = TargetMetadata.from(metadataPtr);
    fullTypeDataMap[typeName].metadata = metadata;
    return metadata;
}
export function metadataFor(typeName, c) {
    const fullTypeData = fullTypeDataMap[typeName];
    if (fullTypeData === undefined) {
        throw new Error("Type not found: " + typeName);
    }
    if (fullTypeData.metadata !== undefined) {
        return fullTypeDataMap[typeName].metadata;
    }
    const metadataPtr = fullTypeData.descriptor
        .getAccessFunction()
        .call();
    const metadata = new c(metadataPtr);
    fullTypeDataMap[typeName].metadata = metadata;
    return metadata;
}
export function getProtocolConformancesFor(typeName) {
    const fullTypeData = fullTypeDataMap[typeName];
    if (fullTypeData === undefined) {
        throw new Error("Type not found: " + typeName);
    }
    return fullTypeData.conformances;
}
export function getAllProtocolDescriptors() {
    return Object.values(protocolDescriptorMap);
}
export function findProtocolDescriptor(protoName) {
    return protocolDescriptorMap[protoName];
}
export function getProtocolDescriptor(protoName) {
    const desc = protocolDescriptorMap[protoName];
    if (desc === undefined) {
        throw new Error(`Can't find protocol descriptor for: "${protoName}"`);
    }
    return desc;
}
function enumerateTypeDescriptors(module) {
    const result = [];
    const section = getSwift5TypesSection(module);
    const nTypes = section.size / RelativeDirectPointer.sizeOf;
    for (let i = 0; i < nTypes; i++) {
        const record = section.vmAddress.add(i * RelativeDirectPointer.sizeOf);
        const ctxDescPtr = RelativeDirectPointer.From(record).get();
        const ctxDesc = new TargetTypeContextDescriptor(ctxDescPtr);
        if (ctxDesc.isGeneric()) {
            continue;
        }
        const kind = ctxDesc.getKind();
        let descriptor;
        switch (kind) {
            case ContextDescriptorKind.Class:
                descriptor = new TargetClassDescriptor(ctxDescPtr);
                break;
            case ContextDescriptorKind.Struct:
                descriptor = new TargetStructDescriptor(ctxDescPtr);
                break;
            case ContextDescriptorKind.Enum:
                descriptor = new TargetEnumDescriptor(ctxDescPtr);
                break;
            default:
                continue;
        }
        result.push(descriptor);
    }
    return result;
}
function enumerateProtocolDescriptors(module) {
    const result = [];
    const section = getSwift5ProtocolsSection(module);
    const numProtos = section.size / RelativeDirectPointer.sizeOf;
    for (let i = 0; i < numProtos; i++) {
        const record = section.vmAddress.add(i * RelativeDirectPointer.sizeOf);
        const ctxDescPtr = RelativeDirectPointer.From(record).get();
        const ctxDesc = new TargetProtocolDescriptor(ctxDescPtr);
        result.push(ctxDesc);
    }
    return result;
}
function bindProtocolConformances(module) {
    const section = getSwift5ProtocolConformanceSection(module);
    const numRecords = section.size / RelativeDirectPointer.sizeOf;
    for (let i = 0; i < numRecords; i++) {
        const recordPtr = section.vmAddress.add(i * RelativeDirectPointer.sizeOf);
        const descPtr = RelativeDirectPointer.From(recordPtr).get();
        const conformanceDesc = new TargetProtocolConformanceDescriptor(descPtr);
        const typeDescPtr = conformanceDesc.getTypeDescriptor();
        const typeDesc = new TargetTypeContextDescriptor(typeDescPtr);
        /** TODO:
         *  - Handle ObjC case explicitly
         *  - Implement protocol inheritance
         *  - Implement generics
         */
        if (typeDescPtr === null ||
            typeDesc.isGeneric() ||
            typeDesc.getKind() === ContextDescriptorKind.Protocol) {
            continue;
        }
        const type = fullTypeDataMap[typeDesc.getFullTypeName()];
        if (type === undefined) {
            continue;
        }
        if (conformanceDesc.protocol.isNull()) {
            /* Since we can't read the protocol's name via its conformance descriptor, we try to extract it via the
            conformance descriptor's symbol. */
            const mangledSymbol = demangledSymbolFromAddress(descPtr);
            const protocolName = findProtocolNameInConformanceDescriptor(mangledSymbol);
            if (protocolName === null) {
                console.warn(`Failed to parse protocol name from conformance descriptor '${mangledSymbol}'. Please file a bug.`);
                continue;
            }
            type.conformances[protocolName] = {
                protocol: null,
                witnessTable: null,
            };
        }
        else {
            const protocolDesc = new TargetProtocolDescriptor(conformanceDesc.protocol);
            type.conformances[protocolDesc.name] = {
                protocol: protocolDesc,
                witnessTable: conformanceDesc.witnessTablePattern,
            };
        }
    }
}
function getSwift5TypesSection(module) {
    return getMachoSection(module, "__swift5_types");
}
function getSwift5ProtocolsSection(module) {
    return getMachoSection(module, "__swift5_protos");
}
function getSwift5ProtocolConformanceSection(module) {
    return getMachoSection(module, "__swift5_proto");
}
function getMachoSection(module, sectionName, segmentName = "__TEXT") {
    const machHeader = module.base;
    const segName = Memory.allocUtf8String(segmentName);
    const sectName = Memory.allocUtf8String(sectionName);
    const sizeOut = Memory.alloc(Process.pointerSize);
    const vmAddress = getPrivateAPI().getsectiondata(machHeader, segName, sectName, sizeOut);
    const size = sizeOut.readU32();
    return { vmAddress, size };
}
export function findDemangledSymbol(address) {
    const module = allModules.find(address);
    if (module === null) {
        return undefined;
    }
    const rawAddr = address.toString();
    const cached = demangledSymbols.get(rawAddr);
    if (cached !== undefined) {
        return cached;
    }
    const demangled = demangledSymbolFromAddress(address);
    if (demangled === undefined) {
        return undefined;
    }
    demangledSymbols.set(rawAddr, demangled);
    return demangled;
}
export function getDemangledSymbol(address) {
    const symbol = findDemangledSymbol(address);
    if (symbol === undefined) {
        throw new Error("Can't find symbol at " + address.toString());
    }
    return symbol;
}
