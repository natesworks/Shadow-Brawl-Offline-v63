/**
 * TODO:
 *  - Implement TargetProtocolRequirement
 *  - Implement TargetEnumDescriptor
 *  - Use a cleaner property-caching approach
 */
import { ContextDescriptorKind, MetadataKind, TargetValueWitnessFlags, TypeContextDescriptorFlags, MethodDescriptorFlags, TypeReferenceKind, ConformanceFlags, getEnumeratedMetadataKind, ProtocolContextDescriptorFlags, } from "./metadatavalues.js";
import { RelativeDirectPointer, RelativeIndirectablePointer, } from "../basic/relativepointer.js";
import { BoxPair } from "../runtime/heapobject.js";
import { getApi } from "../lib/api.js";
export class TargetValueBuffer {
    privateData;
    constructor(privateData) {
        this.privateData = privateData;
    }
}
export class TargetMetadata {
    handle;
    static OFFSETOF_KIND = 0x0;
    #kind;
    constructor(handle) {
        this.handle = handle;
        this.#kind = this.handle.add(TargetMetadata.OFFSETOF_KIND).readU32();
    }
    getKind() {
        return getEnumeratedMetadataKind(this.#kind);
    }
    isClassObject() {
        return this.getKind() == MetadataKind.Class;
    }
    getValueWitnesses() {
        const kind = this.getKind();
        if (kind !== MetadataKind.Enum && kind !== MetadataKind.Struct) {
            throw new Error(`Kind does not have a VWT: ${kind}`);
        }
        const handle = this.handle.sub(Process.pointerSize).readPointer();
        return new TargetValueWitnessTable(handle);
    }
    getTypeLayout() {
        const valueWitnesses = this.getValueWitnesses();
        return {
            size: valueWitnesses.size,
            stride: valueWitnesses.stride,
            flags: valueWitnesses.flags.data,
            extraInhabitantCount: valueWitnesses.extraInhabitantCount,
        };
    }
    vw_initializeWithCopy(dest, src) {
        return this.getValueWitnesses().initializeWithCopy(dest, src, this.handle);
    }
    vw_getEnumTag(object) {
        return this.getValueWitnesses().asEVWT().getEnumTag(object);
    }
    vw_destructiveInjectEnumTag(object, tag) {
        return this.getValueWitnesses()
            .asEVWT()
            .destructiveInjectEnumTag(object, tag);
    }
    allocateBoxForExistentialIn(buffer) {
        const vwt = this.getValueWitnesses();
        if (vwt.isValueInline()) {
            return buffer.privateData;
        }
        const api = getApi();
        const refAndValue = new BoxPair(api.swift_allocBox(this.handle));
        buffer.privateData.writePointer(refAndValue.object.handle);
        return refAndValue.buffer;
    }
    getFullTypeName() {
        return this.getDescription().getFullTypeName();
    }
    static from(handle) {
        const tmp = new TargetValueMetadata(handle);
        switch (tmp.getKind()) {
            case MetadataKind.Class:
                return new TargetClassMetadata(handle);
            case MetadataKind.Struct:
                return new TargetStructMetadata(handle);
            case MetadataKind.Enum:
                return new TargetEnumMetadata(handle);
            default:
                throw new Error("Unknown metadata kind");
        }
    }
    toJSON() {
        return {
            handle: this.handle,
            name: this.getFullTypeName(),
        };
    }
}
export class TargetValueMetadata extends TargetMetadata {
    static OFFSETOF_DESCRIPTION = Process.pointerSize;
    #description;
    get description() {
        if (this.#description === undefined) {
            this.#description = this.handle
                .add(TargetValueMetadata.OFFSETOF_DESCRIPTION)
                .readPointer();
        }
        return this.#description;
    }
    getDescription() {
        return new TargetValueTypeDescriptor(this.description);
    }
}
export class TargetClassMetadata extends TargetMetadata {
    static OFFSTETOF_DESCRIPTION = Process.pointerSize * 8;
    #description;
    get description() {
        if (this.#description === undefined) {
            this.#description = this.handle
                .add(TargetClassMetadata.OFFSTETOF_DESCRIPTION)
                .readPointer();
        }
        return this.#description;
    }
    getDescription() {
        return new TargetClassDescriptor(this.description);
    }
}
export class TargetStructMetadata extends TargetValueMetadata {
    getDescription() {
        return new TargetStructDescriptor(this.description);
    }
}
export class TargetEnumMetadata extends TargetValueMetadata {
    getDescription() {
        return new TargetEnumDescriptor(this.description);
    }
}
class TargetValueWitnessTable {
    handle;
    static OFFSETOF_INTIALIZE_WITH_COPY = 0x10;
    static OFFSETOF_SIZE = 0x40;
    static OFFSETOF_STRIDE = 0x48;
    static OFFSETOF_FLAGS = 0x50;
    static OFFSETOF_EXTRA_INHABITANT_COUNT = 0x54;
    initializeWithCopy;
    size;
    stride;
    flags;
    extraInhabitantCount;
    constructor(handle) {
        this.handle = handle;
        const ptrInitializeWithCopy = this.handle
            .add(TargetValueWitnessTable.OFFSETOF_INTIALIZE_WITH_COPY)
            .readPointer();
        const initializeWithCopy = new NativeFunction(ptrInitializeWithCopy, "pointer", ["pointer", "pointer", "pointer"]);
        this.initializeWithCopy = (dest, src, self) => {
            return initializeWithCopy(dest, src, self);
        };
        this.size = this.getSize();
        this.stride = this.getStride();
        this.flags = this.getFlags();
        this.extraInhabitantCount = this.getExtraInhabitantCount();
    }
    isValueInline() {
        return this.flags.isInlineStorage;
    }
    getSize() {
        return this.handle
            .add(TargetValueWitnessTable.OFFSETOF_SIZE)
            .readU64()
            .toNumber();
    }
    getStride() {
        return this.handle
            .add(TargetValueWitnessTable.OFFSETOF_STRIDE)
            .readU64()
            .toNumber();
    }
    getAlignmentMask() {
        return this.flags.getAlignmentMask();
    }
    getFlags() {
        const value = this.handle
            .add(TargetValueWitnessTable.OFFSETOF_FLAGS)
            .readU32();
        return new TargetValueWitnessFlags(value);
    }
    getExtraInhabitantCount() {
        return this.handle
            .add(TargetValueWitnessTable.OFFSETOF_EXTRA_INHABITANT_COUNT)
            .readU32();
    }
    asEVWT() {
        return new EnumValueWitnessTable(this.handle);
    }
}
/** Implemented in include/Swift/Runtime/Metadata.h */
export class EnumValueWitnessTable extends TargetValueWitnessTable {
    static OFFSETOF_GET_ENUM_TAG = 0x58;
    static OFFSETOF_DESTRUCTIVE_INJECT_ENUM_TAG = 0x68;
    getEnumTag;
    destructiveInjectEnumTag;
    constructor(handle) {
        super(handle);
        let pointer = this.handle
            .add(EnumValueWitnessTable.OFFSETOF_GET_ENUM_TAG)
            .readPointer();
        const getEnumTag = new NativeFunction(pointer, "uint32", [
            "pointer",
            "pointer",
        ]);
        this.getEnumTag = (object) => {
            return getEnumTag(object, this.handle);
        };
        pointer = this.handle
            .add(EnumValueWitnessTable.OFFSETOF_DESTRUCTIVE_INJECT_ENUM_TAG)
            .readPointer();
        const destructiveInjectEnumTag = new NativeFunction(pointer, "void", [
            "pointer",
            "uint32",
            "pointer",
        ]);
        this.destructiveInjectEnumTag = (object, tag) => {
            return destructiveInjectEnumTag(object, tag, this.handle);
        };
    }
}
export class TargetContextDescriptor {
    handle;
    static OFFSETOF_FLAGS = 0x0;
    static OFFSETOF_PARENT = 0x4;
    #flags;
    #parent;
    constructor(handle) {
        this.handle = handle;
    }
    get flags() {
        if (this.#flags != undefined) {
            return this.#flags;
        }
        const value = this.handle
            .add(TargetContextDescriptor.OFFSETOF_FLAGS)
            .readU32();
        return new ContextDescriptorFlags(value);
    }
    get parent() {
        if (this.#parent !== undefined) {
            return this.#parent;
        }
        this.#parent = RelativeIndirectablePointer.From(this.handle.add(TargetContextDescriptor.OFFSETOF_PARENT));
        return this.#parent;
    }
    isGeneric() {
        return this.flags.isGeneric();
    }
    getKind() {
        return this.flags.getKind();
    }
    getModuleContext() {
        let m = new TargetModuleContextDescriptor(this.parent.get());
        while (m.flags.getKind() !== ContextDescriptorKind.Module) {
            m = new TargetModuleContextDescriptor(m.parent.get());
        }
        return m;
    }
}
export class TargetModuleContextDescriptor extends TargetContextDescriptor {
    static OFFSETOF_NAME = 0x8;
    #name;
    get name() {
        if (this.#name !== undefined) {
            return this.#name;
        }
        const relPtr = this.handle.add(TargetModuleContextDescriptor.OFFSETOF_NAME);
        const absPtr = RelativeDirectPointer.From(relPtr).get();
        this.#name = absPtr.readCString();
        return this.#name;
    }
}
export class TargetTypeContextDescriptor extends TargetContextDescriptor {
    static OFFSETOF_NAME = 0x8;
    static OFFSETOF_ACCESS_FUNCTION_PTR = 0xc;
    static OFFSETOF_FIELDS = 0x10;
    #name;
    #accessFunctionPtr;
    #fields;
    getTypeContextDescriptorFlags() {
        return new TypeContextDescriptorFlags(this.flags.getKindSpecificFlags());
    }
    get name() {
        if (this.#name !== undefined) {
            return this.#name;
        }
        const namePtr = RelativeDirectPointer.From(this.handle.add(TargetTypeContextDescriptor.OFFSETOF_NAME)).get();
        this.#name = namePtr.readUtf8String();
        return this.#name;
    }
    get accessFunctionPointer() {
        if (this.#accessFunctionPtr !== undefined) {
            return this.#accessFunctionPtr;
        }
        return RelativeDirectPointer.From(this.handle.add(TargetTypeContextDescriptor.OFFSETOF_ACCESS_FUNCTION_PTR)).get();
    }
    get fields() {
        if (this.#fields !== undefined) {
            return this.#fields;
        }
        return RelativeDirectPointer.From(this.handle.add(TargetTypeContextDescriptor.OFFSETOF_FIELDS));
    }
    isReflectable() {
        return this.fields !== null;
    }
    getAccessFunction() {
        return new NativeFunction(this.accessFunctionPointer, "pointer", []);
    }
    /* XXX: not in the original source */
    getFullTypeName() {
        return `${this.getModuleContext().name}.${this.name}`;
    }
}
class TargetValueTypeDescriptor extends TargetTypeContextDescriptor {
}
export class TargetClassDescriptor extends TargetTypeContextDescriptor {
    static OFFSETOF_TARGET_VTABLE_DESCRIPTOR_HEADER = 0x2c;
    static OFFSETOF_METHOD_DESCRIPTORS = 0x34;
    hasVTable() {
        return this.getTypeContextDescriptorFlags().class_hasVTable();
    }
    hasResilientSuperClass() {
        return this.getTypeContextDescriptorFlags().class_hasResilientSuperClass();
    }
    hasOverrideTable() {
        return this.getTypeContextDescriptorFlags().class_hasOverrideTable();
    }
    hasSingletonMetadataInitialization() {
        return this.getTypeContextDescriptorFlags().hasSingletonMetadataInitialization();
    }
    hasForeignMetadataInitialization() {
        return this.getTypeContextDescriptorFlags().hasForeignMetadataInitialization();
    }
    getVTableDescriptor() {
        if (!this.hasVTable()) {
            return null;
        }
        const pointer = this.handle.add(TargetClassDescriptor.OFFSETOF_TARGET_VTABLE_DESCRIPTOR_HEADER);
        const vtableHeader = new VTableDescriptorHeader(pointer);
        return vtableHeader;
    }
    getMethodDescriptors() {
        const result = [];
        /** TODO:
         * - Handle the edge cases below
         */
        if (!this.hasVTable() ||
            this.isGeneric() ||
            this.hasResilientSuperClass() ||
            this.hasOverrideTable() ||
            this.hasSingletonMetadataInitialization() ||
            this.hasForeignMetadataInitialization()) {
            return result;
        }
        const vtableSize = this.getVTableDescriptor().vtableSize;
        let i = this.handle.add(TargetClassDescriptor.OFFSETOF_METHOD_DESCRIPTORS);
        const end = i.add(vtableSize * TargetMethodDescriptor.sizeof);
        for (; !i.equals(end); i = i.add(TargetMethodDescriptor.sizeof)) {
            const methodDescriptor = new TargetMethodDescriptor(i);
            /* TODO: figure out what the flags signify in this case */
            if (methodDescriptor.impl === null) {
                continue;
            }
            result.push(methodDescriptor);
        }
        return result;
    }
}
class VTableDescriptorHeader {
    handle;
    static OFFSETOF_VTABLE_OFFSET = 0x0;
    static OFFSETOF_VTABLE_SIZE = 0x4;
    #vtableSize;
    constructor(handle) {
        this.handle = handle;
    }
    get vtableSize() {
        if (this.#vtableSize !== undefined) {
            return this.#vtableSize;
        }
        return this.handle
            .add(VTableDescriptorHeader.OFFSETOF_VTABLE_SIZE)
            .readU32();
    }
}
class TargetMethodDescriptor {
    handle;
    static OFFSETOF_FLAGS = 0x0;
    static OFFSETOF_IMPL = 0x4;
    static sizeof = 8;
    #flags;
    #impl;
    constructor(handle) {
        this.handle = handle;
    }
    get flags() {
        if (this.#flags !== undefined) {
            return this.#flags;
        }
        const value = this.handle
            .add(TargetMethodDescriptor.OFFSETOF_FLAGS)
            .readU32();
        return new MethodDescriptorFlags(value);
    }
    get impl() {
        if (this.#impl !== undefined) {
            return this.#impl;
        }
        const pointer = this.handle.add(TargetMethodDescriptor.OFFSETOF_IMPL);
        return RelativeDirectPointer.From(pointer);
    }
}
export class TargetStructDescriptor extends TargetTypeContextDescriptor {
    static OFFSETOF_NUM_FIELDS = 0x18;
    static OFFSETOF_FIELD_OFFSET_VECTOR_OFFSET = 0x1c;
    #numFields;
    #fieldOffsetVectorOffset;
    hasFieldOffsetVector() {
        return this.fieldOffsetVectorOffset !== 0;
    }
    get numFields() {
        if (this.#numFields !== undefined) {
            return this.#numFields;
        }
        return this.handle
            .add(TargetStructDescriptor.OFFSETOF_NUM_FIELDS)
            .readU32();
    }
    get fieldOffsetVectorOffset() {
        if (this.#fieldOffsetVectorOffset !== undefined) {
            return this.#fieldOffsetVectorOffset;
        }
        return this.handle
            .add(TargetStructDescriptor.OFFSETOF_FIELD_OFFSET_VECTOR_OFFSET)
            .readU32();
    }
}
export class TargetEnumDescriptor extends TargetTypeContextDescriptor {
    static OFFSETOF_NUM_PAYLOAD_CASES_AND_PAYLOAD_SIZE_OFFSET = 0x14;
    static OFFSETOF_NUM_EMPTY_CASES = 0x18;
    #numPayloadCasesAndPayloadSizeOffset;
    #numEmptyCases;
    get numPayloadCasesAndPayloaadSizeOffset() {
        if (this.#numPayloadCasesAndPayloadSizeOffset === undefined) {
            const num = this.handle
                .add(TargetEnumDescriptor.OFFSETOF_NUM_PAYLOAD_CASES_AND_PAYLOAD_SIZE_OFFSET)
                .readU32();
            this.#numPayloadCasesAndPayloadSizeOffset = num;
        }
        return this.#numPayloadCasesAndPayloadSizeOffset;
    }
    get numEmptyCases() {
        if (this.#numEmptyCases === undefined) {
            this.#numEmptyCases = this.handle
                .add(TargetEnumDescriptor.OFFSETOF_NUM_EMPTY_CASES)
                .readU32();
        }
        return this.#numEmptyCases;
    }
    getNumPayloadCases() {
        return this.numPayloadCasesAndPayloaadSizeOffset & 0x00ffffff;
    }
    getNumEmptyCases() {
        return this.numEmptyCases;
    }
    getNumCases() {
        return this.getNumPayloadCases() + this.numEmptyCases;
    }
    /* XXX: not in the original source */
    isPayloadTag(tag) {
        return this.getNumCases() > 0 && tag < this.getNumPayloadCases();
    }
}
export class TargetProtocolDescriptor extends TargetContextDescriptor {
    static OFFSETOF_NAME = 0x8;
    static OFFSETOF_NUM_REQUIREMENTS = 0x10;
    #name;
    #numRequirements;
    constructor(handle) {
        super(handle);
    }
    get name() {
        if (this.#name === undefined) {
            const pointer = RelativeDirectPointer.From(this.handle.add(TargetProtocolDescriptor.OFFSETOF_NAME)).get();
            this.#name = pointer.readCString();
        }
        return this.#name;
    }
    get numRequirements() {
        if (this.#numRequirements === undefined) {
            const pointer = this.handle.add(TargetProtocolDescriptor.OFFSETOF_NUM_REQUIREMENTS);
            this.#numRequirements = pointer.readU32();
        }
        return this.#numRequirements;
    }
    getProtocolContextDescriptorFlags() {
        return new ProtocolContextDescriptorFlags(this.flags.getKindSpecificFlags());
    }
    getFullProtocolName() {
        return this.getModuleContext().name + "." + this.name;
    }
}
class TargetTypeReference {
    handle;
    constructor(handle) {
        this.handle = handle;
    }
    getTypeDescriptor(kind) {
        let pointer = null;
        switch (kind) {
            case TypeReferenceKind.DirectTypeDescriptor:
                pointer = RelativeDirectPointer.From(this.handle).get();
                break;
            case TypeReferenceKind.IndirectTypeDescriptor:
                pointer = RelativeDirectPointer.From(this.handle).get();
                pointer = pointer.readPointer();
                break;
            /* TODO: what to do with those? */
            case TypeReferenceKind.DirectObjCClassName:
            case TypeReferenceKind.IndirectObjCClass:
                break;
        }
        return pointer;
    }
}
export class TargetProtocolConformanceDescriptor {
    handle;
    static OFFSETOF_PROTOTCOL = 0x0;
    static OFFSETOF_TYPE_REF = 0x4;
    static OFFSTEOF_WITNESS_TABLE_PATTERN = 0x8;
    static OFFSETOF_FLAGS = 0xc;
    static OFFSETOF_WITNESS_TABLE_PATTERN = 0x10;
    #protocol;
    #typeRef;
    #witnessTablePattern;
    #flags;
    constructor(handle) {
        this.handle = handle;
    }
    get protocol() {
        if (this.#protocol === undefined) {
            this.#protocol = RelativeIndirectablePointer.From(this.handle.add(TargetProtocolConformanceDescriptor.OFFSETOF_PROTOTCOL)).get();
        }
        return this.#protocol;
    }
    get typeRef() {
        if (this.#typeRef === undefined) {
            const pointer = this.handle.add(TargetProtocolConformanceDescriptor.OFFSETOF_TYPE_REF);
            this.#typeRef = new TargetTypeReference(pointer);
        }
        return this.#typeRef;
    }
    /* This is actually the protocol witness table */
    get witnessTablePattern() {
        if (this.#witnessTablePattern === undefined) {
            const witnessTable = RelativeDirectPointer.From(this.handle.add(TargetProtocolConformanceDescriptor.OFFSTEOF_WITNESS_TABLE_PATTERN));
            this.#witnessTablePattern = witnessTable
                ? witnessTable.get()
                : null;
        }
        return this.#witnessTablePattern;
    }
    get flags() {
        if (this.#flags === undefined) {
            const pointer = this.handle.add(TargetProtocolConformanceDescriptor.OFFSETOF_FLAGS);
            this.#flags = new ConformanceFlags(pointer.readU32());
        }
        return this.#flags;
    }
    getTypeKind() {
        return this.flags.getTypeReferenceKind();
    }
    getTypeDescriptor() {
        return this.typeRef.getTypeDescriptor(this.getTypeKind());
    }
}
class ContextDescriptorFlags {
    value;
    constructor(value) {
        this.value = value;
    }
    getKind() {
        return this.value & 0x1f;
    }
    isGeneric() {
        return (this.value & 0x80) !== 0;
    }
    getIntValue() {
        return this.value;
    }
    getKindSpecificFlags() {
        return (this.value >>> 16) & 0xffff;
    }
}
