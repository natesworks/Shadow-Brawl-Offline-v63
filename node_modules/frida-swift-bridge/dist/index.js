/**
 * TODO:
 *  - Use proper platform checks (CPU and OS)
 *  - Use strict null checks?
 *  - Use platform-agnostic data structure sizes (size_t et al.)
 *  - Register for notification when a new module is added
 *  - Add demangled symbol look-up
 *  - Add parsing of function names
 *  - inout params
 */
import { getApi, getPrivateAPI } from "./lib/api.js";
import { Protocol, ProtocolComposition, EnumValue, ObjectInstance, StructValue, Type, } from "./lib/types.js";
import { makeSwiftNativeFunction, } from "./lib/callingconvention.js";
import { Registry } from "./lib/registry.js";
import { SwiftInterceptor } from "./lib/interceptor.js";
import { getSymbolicator } from "./lib/symbols.js";
class Runtime {
    #api = null;
    #initializatioError = null;
    constructor() {
        try {
            this.tryInitialize();
        }
        catch (e) {
            /* empty */
        }
    }
    get available() {
        try {
            return this.tryInitialize();
        }
        catch (e) {
            return false;
        }
    }
    get api() {
        return this.#api;
    }
    get modules() {
        return Registry.shared().modules;
    }
    get classes() {
        return Registry.shared().classes;
    }
    get structs() {
        return Registry.shared().structs;
    }
    get enums() {
        return Registry.shared().enums;
    }
    get protocols() {
        return Registry.shared().protocols;
    }
    Object = ObjectInstance;
    Struct = StructValue;
    Enum = EnumValue;
    ProtocolComposition = ProtocolComposition;
    Interceptor = SwiftInterceptor;
    NativeFunction(address, retType, argTypes, context, throws) {
        function getNativeType(type) {
            if (type instanceof Type) {
                return type.$metadata;
            }
            else if (type instanceof Protocol) {
                return new ProtocolComposition(type);
            }
            return type;
        }
        const nativeRetType = getNativeType(retType);
        const nativeArgType = argTypes.map((ty) => getNativeType(ty));
        return makeSwiftNativeFunction(address, nativeRetType, nativeArgType, context, throws);
    }
    tryInitialize() {
        if (this.#api !== null) {
            return true;
        }
        if (this.#initializatioError !== null) {
            throw this.#initializatioError;
        }
        try {
            this.#api = getApi();
            /* Call these for their side effects, i.e. throwing on failure */
            getPrivateAPI();
            getSymbolicator();
        }
        catch (e) {
            this.#initializatioError = e;
            throw e;
        }
        return this.#api !== null;
    }
}
export default new Runtime();
